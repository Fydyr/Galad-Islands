#!/usr/bin/env python3
"""
Script de pr√©-entra√Ænement pour l'IA Barhamus (Maraudeur Zeppelin).
Simule des combats tactiques pour entra√Æner le mod√®le de d√©cision.
Son entrainement en jeu existe toujours mais permet d'avoir une base plus solide et avoid de prendre trop en performance.
"""
import sys
import os
import time
import random
import numpy as np
from pathlib import Path
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.tree import DecisionTreeClassifier
import pickle
from sklearn.preprocessing import StandardScaler
import joblib

# Add the directory src au path
sys.path.insert(0, str(Path(__file__).parent / "src"))

# Importer les components n√©cessaires
from src.ia.ia_barhamus import BarhamusAI
from src.components.core.positionComponent import PositionComponent
from src.components.core.velocityComponent import VelocityComponent
from src.components.core.healthComponent import HealthComponent
from src.components.core.teamComponent import TeamComponent
from src.components.special.speMaraudeurComponent import SpeMaraudeur
from src.constants.map_tiles import TileType
from src.settings.settings import TILE_SIZE
from src.components.globals.mapComponent import creer_grille, placer_elements
from src.functions.resource_path import get_resource_path
from src.ia.ia_barhamus import get_app_data_path

class BarhamusTrainer:
    """Entra√Æneur pour l'IA Barhamus avec simulation de combats tactiques."""

    def __init__(self):
        self.map_width = 50  # 50 tiles
        self.map_height = 50  # 50 tiles
        self.tile_size = TILE_SIZE
        self.max_simulation_time = 300.0  # 5 minutes max par simulation
        self.time_step = 0.1  # 100ms par step

        # Chemin des mod√®les
        self.models_dir = get_app_data_path()
        self.pretrained_model_path = os.path.join(self.models_dir, "barhamus_pretrained.pkl")

        # Statistiques d'entra√Ænement
        self.total_experiences = 0
        self.successful_trainings = 0

    def create_mock_world(self):
        """creates un monde simul√© basique pour les tests."""
        class MockWorld:
            def __init__(self, trainer):
                self.trainer = trainer
                self.entities = {}
                self.components = {}

            def has_component(self, entity, component_type):
                return entity in self.components and component_type in self.components[entity]

            def component_for_entity(self, entity, component_type):
                if self.has_component(entity, component_type):
                    return self.components[entity][component_type]
                return None

            def create_entity(self):
                entity_id = len(self.entities)
                self.entities[entity_id] = {}
                self.components[entity_id] = {}
                return entity_id

            def get_component(self, component_type):
                """Simule esper.get_component"""
                results = []
                for entity_id, entity_components in self.components.items():
                    if component_type in entity_components:
                        results.append((entity_id, entity_components[component_type]))
                return results

            def get_components(self, *component_types):
                """Simule esper.get_components"""
                results = []
                for entity_id, entity_components in self.components.items():
                    components = []
                    for comp_type in component_types:
                        if comp_type in entity_components:
                            components.append(entity_components[comp_type])
                        else:
                            break
                    else:
                        results.append((entity_id, tuple(components)))
                return results

        return MockWorld(self)

    def create_barhamus_entity(self, world, x, y, team_id=1):
        """Create an entity Barhamus avec all components n√©cessaires."""
        entity = world.create_entity()

        # Position
        pos = PositionComponent()
        pos.x = x
        pos.y = y
        pos.direction = 0.0
        world.components[entity][PositionComponent] = pos

        # V√©locit√©
        vel = VelocityComponent()
        vel.currentSpeed = 0.0
        vel.maxUpSpeed = 5.0
        vel.maxReverseSpeed = 3.0
        world.components[entity][VelocityComponent] = vel

        # Sant√©
        health = HealthComponent()
        health.currentHealth = 100
        health.maxHealth = 100
        world.components[entity][HealthComponent] = health

        # √âquipe
        team = TeamComponent()
        team.team_id = team_id
        world.components[entity][TeamComponent] = team

        # component sp√©cial Maraudeur
        spe = SpeMaraudeur()
        spe.is_active = False
        spe.cooldown_timer = 0.0
        world.components[entity][SpeMaraudeur] = spe

        return entity

    def create_enemy_entity(self, world, x, y, team_id=2):
        """Create an entity ennemie basique."""
        entity = world.create_entity()

        # Position
        pos = PositionComponent()
        pos.x = x
        pos.y = y
        pos.direction = 0.0
        world.components[entity][PositionComponent] = pos

        # Sant√©
        health = HealthComponent()
        health.currentHealth = 80
        health.maxHealth = 80
        world.components[entity][HealthComponent] = health

        # √âquipe
        team = TeamComponent()
        team.team_id = team_id
        world.components[entity][TeamComponent] = team

        return entity

    def generate_tactical_scenarios(self, n_per_scenario=500):
        """G√©n√®re des sc√©narios tactiques pour l'entra√Ænement."""
        scenarios = []
        experiences = []

        print("üéØ G√©n√©ration des sc√©narios tactiques...")

        # Sc√©nario 1: Combat rapproch√© d√©fensif
        print("  ‚Üí Combat rapproch√© d√©fensif")
        for _ in range(n_per_scenario):
            world = self.create_mock_world()
            barhamus = self.create_barhamus_entity(world, 500, 500, 1)

            # Ennemis proches
            enemies = []
            for i in range(random.randint(2, 4)):
                angle = random.uniform(0, 2 * np.pi)
                distance = random.uniform(200, 400)
                x = 500 + distance * np.cos(angle)
                y = 500 + distance * np.sin(angle)
                enemy = self.create_enemy_entity(world, x, y, 2)
                enemies.append(enemy)

            scenario = {
                'world': world,
                'barhamus': barhamus,
                'enemies': enemies,
                'description': 'combat_rapproche_defensif',
                'expected_strategy': 'defensive'
            }
            scenarios.append(scenario)

        # Sc√©nario 2: Combat √† distance offensif
        print("  ‚Üí Combat √† distance offensif")
        for _ in range(n_per_scenario):
            world = self.create_mock_world()
            barhamus = self.create_barhamus_entity(world, 500, 500, 1)

            # Ennemis lointains
            enemies = []
            for i in range(random.randint(1, 3)):
                angle = random.uniform(0, 2 * np.pi)
                distance = random.uniform(800, 1200)
                x = 500 + distance * np.cos(angle)
                y = 500 + distance * np.sin(angle)
                enemy = self.create_enemy_entity(world, x, y, 2)
                enemies.append(enemy)

            scenario = {
                'world': world,
                'barhamus': barhamus,
                'enemies': enemies,
                'description': 'combat_distance_offensif',
                'expected_strategy': 'aggressive'
            }
            scenarios.append(scenario)

        # Sc√©nario 3: Embuscade tactique
        print("  ‚Üí Embuscade tactique")
        for _ in range(n_per_scenario):
            world = self.create_mock_world()
            barhamus = self.create_barhamus_entity(world, 500, 500, 1)

            # Un ennemi isol√©
            enemy = self.create_enemy_entity(world, 800, 300, 2)
            enemies = [enemy]

            scenario = {
                'world': world,
                'barhamus': barhamus,
                'enemies': enemies,
                'description': 'embuscade_tactique',
                'expected_strategy': 'tactical'
            }
            scenarios.append(scenario)

        # Sc√©nario 4: Fuite d√©fensive
        print("  ‚Üí Fuite d√©fensive")
        for _ in range(n_per_scenario):
            world = self.create_mock_world()
            barhamus = self.create_barhamus_entity(world, 500, 500, 1)

            # Sant√© basse, ennemis nombreux
            health = world.components[barhamus][HealthComponent]
            health.currentHealth = random.uniform(20, 40)

            enemies = []
            for i in range(random.randint(3, 6)):
                angle = random.uniform(0, 2 * np.pi)
                distance = random.uniform(300, 600)
                x = 500 + distance * np.cos(angle)
                y = 500 + distance * np.sin(angle)
                enemy = self.create_enemy_entity(world, x, y, 2)
                enemies.append(enemy)

            scenario = {
                'world': world,
                'barhamus': barhamus,
                'enemies': enemies,
                'description': 'fuite_defensive',
                'expected_strategy': 'defensive'
            }
            scenarios.append(scenario)

        return scenarios

    def _create_real_grid(self):
        """creates une vraie grille de jeu avec all √©l√©ments."""
        grid = creer_grille()  # Grille vide remplie de SEA
        placer_elements(grid)  # Place les bases, √Æles, mines, nuages
        return grid

    def _get_enemies_in_range(self, world, pos, entity, range_distance):
        """Retourne les ennemis √† port√©e."""
        enemies_in_range = []
        team = world.components[entity][TeamComponent]

        for enemy_entity, components in world.components.items():
            if TeamComponent in components and components[TeamComponent].team_id != team.team_id:
                if PositionComponent in components:
                    enemy_pos = components[PositionComponent]
                    distance = np.sqrt((pos.x - enemy_pos.x)**2 + (pos.y - enemy_pos.y)**2)
                    if distance <= range_distance:
                        enemies_in_range.append(enemy_entity)

        return enemies_in_range

    def train_barhamus_model(self, n_scenarios=1000, n_iterations=3):
        """Entra√Æne le mod√®le Barhamus avec les sc√©narios g√©n√©r√©s."""
        print("\nüöÄ PR√â-ENTRA√éNEMENT DE L'IA BARHAMUS")
        print("=" * 60)

        all_experiences = []
        autosave_path = os.path.join(self.models_dir, "barhamus_training_autosave.pkl")

        # Reprise si autosave existant
        if os.path.exists(autosave_path):
            print(f"‚ö†Ô∏è Fichier autosave {autosave_path} d√©tect√©. Reprise possible.")
            try:
                with open(autosave_path, 'rb') as f:
                    all_experiences = pickle.load(f)
                print(f"‚û°Ô∏è Reprise avec {len(all_experiences)} exp√©riences d√©j√† collect√©es.")
            except Exception as e:
                print(f"Erreur lors du chargement du fichier autosave : {e}")

        try:
            # Create une seule IA pour collecter les donn√©es
            ai_collector = BarhamusAI(entity=0)
            ai_collector.grid = self._create_real_grid()
            
            # Restaurer les donn√©es from l'autosave si elles existent
            X = [exp['state'] for exp in all_experiences]
            y = [exp['action'] for exp in all_experiences]
            all_experiences.clear() # Vider pour avoid la redondance m√©moire

            for iteration in range(n_iterations):
                print(f"\nüîÑ It√©ration {iteration + 1}/{n_iterations}")

                # G√©n√©rer des sc√©narios
                print("üéØ G√©n√©ration des sc√©narios tactiques...")
                scenarios = self.generate_tactical_scenarios(n_per_scenario=n_scenarios // 4)
                print(f"  ‚úì {len(scenarios)} sc√©narios g√©n√©r√©s")

                total_scenarios = len(scenarios)
                for i, scenario in enumerate(scenarios):
                    if (i + 1) % (total_scenarios // 4 or 1) == 0:
                        print(f"  Simulation: {i + 1}/{total_scenarios} sc√©narios ({(i + 1) * 100 // total_scenarios}%)")
                    
                    # Extraire l'√©tat et l'action attendue
                    world = scenario['world']
                    barhamus_entity = scenario['barhamus']
                    pos = world.components[barhamus_entity][PositionComponent]
                    health = world.components[barhamus_entity][HealthComponent]
                    team = world.components[barhamus_entity][TeamComponent]
                    
                    state = ai_collector._analyze_situation(world, pos, health, team)
                    
                    # Utiliser la logique By default pour d√©terminer la "meilleure" action pour ce sc√©nario
                    action = ai_collector._get_default_action(state)
                    
                    X.append(state)
                    y.append(action)
                    
                    # Sauvegarde p√©riodique
                    if len(X) % 5000 == 0 and len(X) > 0:
                        experiences_to_save = [{'state': s, 'action': a} for s, a in zip(X, y)]
                        with open(autosave_path, 'wb') as f:
                            pickle.dump(experiences_to_save, f)
                        print(f"üíæ Sauvegarde auto: {len(X)} exp√©riences")

                print(f"  ‚úì It√©ration {iteration + 1} termin√©e: {len(X)} exp√©riences totales")

        except KeyboardInterrupt:
            print("\n‚èπÔ∏è Interruption utilisateur (Ctrl+C) : sauvegarde des exp√©riences...")
            experiences_to_save = [{'state': s, 'action': a} for s, a in zip(X, y)]
            with open(autosave_path, 'wb') as f:
                pickle.dump(experiences_to_save, f)
            print(f"‚úÖ Exp√©riences sauvegard√©es dans {autosave_path}")
            raise
        except Exception as e:
            print(f"\nüí• Exception inattendue : {e}\nSauvegarde des exp√©riences...")
            experiences_to_save = [{'state': s, 'action': a} for s, a in zip(X, y)]
            with open(autosave_path, 'wb') as f:
                pickle.dump(experiences_to_save, f)
            print(f"‚úÖ Exp√©riences sauvegard√©es dans {autosave_path}")
            raise
        finally:
            if X:
                print("\nüíæ Sauvegarde automatique des exp√©riences...")
                experiences_to_save = [{'state': s, 'action': a} for s, a in zip(X, y)]
                with open(autosave_path, 'wb') as f:
                    pickle.dump(experiences_to_save, f)
                print(f"‚úÖ Exp√©riences sauvegard√©es dans {autosave_path}")

        print(f"\nüìà Total exp√©riences collect√©es: {len(X)}")

        if len(X) < 100:
            print("‚ö†Ô∏è Pas assez d'exp√©riences pour entra√Æner le mod√®le.")
            return None, None

        # Pr√©parer les donn√©es d'entra√Ænement

        X = np.array(X)
        y = np.array(y)

        # Calculer les poids bas√©s sur les r√©compenses
        weights = np.ones(len(X))  # Poids uniformes, car nous n'utilisons plus de r√©compenses complexes

        print(f"  Dimensions: {X.shape[0]} √©chantillons, {X.shape[1]} features")

        # Split train/test
        X_train, X_test, y_train, y_test, weights_train, weights_test = train_test_split(
            X, y, weights, test_size=0.2, random_state=42, stratify=y if len(np.unique(y)) > 1 else None
        )

        # Entra√Æner le mod√®le
        print("\nüéØ Entra√Ænement du mod√®le Decision Tree...")
        model = DecisionTreeClassifier(
            random_state=42,
            max_depth=8,
            min_samples_split=20,
            min_samples_leaf=10
        )

        model.fit(X_train, y_train, sample_weight=weights_train)

        # √âvaluer le mod√®le
        y_pred = model.predict(X_test)
        accuracy = accuracy_score(y_test, y_pred)
        print(f"‚úÖ Pr√©cision du mod√®le: {accuracy:.3f}")

        # Entra√Æner le scaler
        print("\nüîß Entra√Ænement du scaler...")
        scaler = StandardScaler()
        scaler.fit(X_train)

        # Sauvegarder le mod√®le et le scaler in un seul file compatible avec BarhamusAI
        os.makedirs(self.models_dir, exist_ok=True)
        model_data = {
            'decision_tree': model,
            'scaler': scaler,
            'is_trained': True
        }
        with open(self.pretrained_model_path, "wb") as f:
            pickle.dump(model_data, f)
        print(f"üíæ Mod√®le et scaler sauvegard√©s: {self.pretrained_model_path}")

        print("=" * 60)
        print("‚ú® PR√â-ENTRA√éNEMENT BARHAMUS TERMIN√â !")
        print("üéÆ L'IA Barhamus est maintenant pr√©-entra√Æn√©e et pr√™te √† jouer !")

        return model, scaler

def main():
    print("ü§ñ Pr√©-entra√Æneur IA Barhamus pour Galad Islands\n")
    import argparse
    parser = argparse.ArgumentParser(description='Pr√©-entra√Æneur IA Barhamus pour Galad Islands.')
    parser.add_argument('--n_scenarios', type=int, default=2000, help='Nombre de sc√©narios par type (d√©faut: 2000)')
    parser.add_argument('--n_iterations', type=int, default=5, help='Nombre d\'it√©rations d\'entra√Ænement (d√©faut: 5)')
    parser.add_argument('--seed', type=int, default=42, help='Graine al√©atoire pour reproductibilit√© (d√©faut: 42)')
    args = parser.parse_args()

    random.seed(args.seed)
    np.random.seed(args.seed)

    trainer = BarhamusTrainer()
    model, scaler = trainer.train_barhamus_model(
        n_scenarios=args.n_scenarios,
        n_iterations=args.n_iterations
    )

    if model and scaler:
        print("\nüéÆ Le mod√®le pr√©-entra√Æn√© est pr√™t √† √™tre utilis√© dans le jeu!")
        print("üí° L'IA Barhamus chargera automatiquement le mod√®le si disponible.")
        print("üîÑ Elle continuera √† apprendre en jeu si l'option 'd√©sactiver apprentissage IA' n'est pas coch√©e.")

if __name__ == "__main__":
    main()