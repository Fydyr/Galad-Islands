---
i18n:
  en: "Production Deployment"
  fr: "Déploiement en production"
---

# Production Deployment

## Compilation for production

### Method 1: Folder-based build (recommended)

This repository now supports building as a folder (PyInstaller "onedir"), which keeps most resources outside the single binary. This is easier to debug and better for applications with large data sets (assets, models, localization modules).

To build all executables in one run you can use the project provided `build.spec` which will generate a directory per executable inside `dist/`:

```bash
# Use the spec file which creates an onedir build for each executable
pyinstaller build.spec

# The output will be available in dist/
# - dist/galad-islands/
# - dist/galad-config-tool/
# - dist/MaraudeurAiCleaner/
```

### Packaging note

The GitHub Actions packaging step gathers these onedir builds into a single ZIP, de-duplicating `assets/` and `models/`. To reproduce locally:

```bash
pyinstaller build.spec
bash tools/package_release.sh Linux # or Mac
```

### Windows packaging

```powershell
pyinstaller build.spec
.\tools\package_release.ps1 Windows
```

#### Game compilation

```bash
# Install PyInstaller
pip install pyinstaller

# For a single-file build (legacy option) replace with --onefile
pyinstaller --onefile --windowed \
    --add-data "assets:assets" \
    --name "GaladIslands" \
    main.py

# The executable is in dist/GaladIslands
# Remember to copy necessary asset folders
```

#### Configuration tool compilation

```bash
pyinstaller --onefile --windowed \
    --add-data "assets:assets" \
    --add-data "assets/locales:assets/locales" \
    --name "GaladConfigTool" \
    src/tools/galad_config_tool.py
```

### Method 2: Python distribution

```bash
# Prepare the environment
python3 -m venv venv_prod
source venv_prod/bin/activate
pip install -r requirements.txt

# Create a launch script
cat > start_game.sh << 'EOF'
#!/bin/bash
cd "$(dirname "$0")"
./venv_prod/bin/python main.py
EOF
chmod +x start_game.sh
```

## Production package structure

```txt
galad-islands-<OS>/              # final package (example: galad-islands-Linux/)
├── galad-islands                # Game executable (Linux/macOS) — Windows: `galad-islands.exe`
├── galad-config-tool            # Configuration tool executable — Windows: `galad-config-tool.exe`
├── MaraudeurAiCleaner           # AI cleanup tool — Windows: `MaraudeurAiCleaner.exe`
├── _internal/                   # Unified native libs shared by executables
├── README.md                    # Packaging and installation instructions
└── galad_config.json            # Configuration (created automatically if missing)
```

## Deployment instructions

### For end users

1. **Download** the complete package
2. **Extract** into a folder
3. **Launch** the `GaladIslands` executable


## Build & Release refactor (technical)

The build and release system has been refactored to be more consistent and resilient across platforms and CI.

### Goals

- Create reproducible onedir builds for all executables and package them into a single release ZIP.
- Deduplicate assets and models across the onedir outputs to keep releases smaller.
- Add robust caching in GitHub Actions so subsequent builds reuse pip packages and PyInstaller caches.
- Use a stable pip cache key based on `requirements.lock` when available.

### What changed (high level)

- The `build.spec` was created to build all executables as onedir outputs in one PyInstaller run.
- The GitHub Actions workflows (`.github/workflows/test-build.yml`, `manual-release.yml`, `release.yml`) now share the same build steps:
  - Detect the pip cache directory per-OS (Linux/macOS vs Windows) and expose it as a step output.
  - Compute the pip cache key using the SHA-256 of `requirements.lock` if present, otherwise `requirements.txt`.
  - Use `actions/cache` to cache pip packages and the PyInstaller build directory (`build/`).
  - Use a `pyinstaller build.spec` step that produces onedir builds for each executable.
- Packaging scripts are available under `tools/`:
  - `tools/package_release.sh` — Linux/macOS bash packaging script that combines onedir outputs into a single ZIP and deduplicates `assets/` and `models/`.
  - `tools/package_release.ps1` — PowerShell packaging script for Windows with similar deduplication logic.

### Packaging details

- The packaging step produces a single archive `galad-islands-<OS>.zip` with the following properties:
  - Top-level executables: `galad-islands`, `galad-config-tool`, `MaraudeurAiCleaner` (name depends on OS).
  - `_internal/` libraries are unified into a single `_internal/` folder so that binaries share the same libs instead of having per-executable copies.
  - Executable collisions are handled by temporary renaming during the packaging process to avoid accidental overwrites.

### CI specifics and cache stability

- The pipeline computes a stable key for `actions/cache` by taking the SHA256 of `requirements.lock` when it exists. This avoids unnecessary cache churn.
- If `requirements.lock` is absent, it falls back to hashing `requirements.txt`.
- The `pyinstaller` build directory is cached by hashing `build.spec` and the main entry points, so PyInstaller can reuse previous analysis.

-### Windows fixes

- PowerShell path handling was hardened; the pipeline uses `Test-Path -LiteralPath` to avoid issues with trailing backslashes or expanded variables that can break `pwsh -c` strings.

### How to run the new packaging flow locally (Linux/macOS)

1. Build onedir output for all executables:

```bash
pyinstaller build.spec
```

1. Run packaging script for your OS (example: Linux):

```bash
bash tools/package_release.sh Linux
# produces galad-islands-Linux.zip in the repo root
```

1. Inspect the produced ZIP to confirm assets and models were deduplicated and `_internal/` is unified.

### How to test CI caching locally

- Make sure your repository has a `requirements.lock` created (e.g., `pip-compile` or similar), then push to the branch and check the `test-build` job logs for `actions/cache` hit/miss messages.
- Look for `Cache hit occurred` for the pip cache and the PyInstaller build cache on subsequent runs.
